<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Second purpose of this package ¬∑ AlternatingProjections.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://olejorik.github.io/AlternatingProjections.jl/stable/methodology/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">AlternatingProjections.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Second purpose of this package</a><ul class="internal"><li><a class="tocitem" href="#Example-of-type-hierarchy:-FeasibleSet"><span>Example of type hierarchy: <code>FeasibleSet</code></span></a></li><li><a class="tocitem" href="#Problem-and-Algorithm-abstract-types"><span><code>Problem</code>  and <code>Algorithm</code> abstract types</span></a></li><li><a class="tocitem" href="#Function-solve"><span>Function <code>solve</code></span></a></li><li><a class="tocitem" href="#Function-project"><span>Function <code>project</code></span></a></li><li><a class="tocitem" href="#Workflow-and-package-structure"><span>Workflow and package structure</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Second purpose of this package</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Second purpose of this package</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/olejorik/AlternatingProjections.jl/blob/master/docs/src/methodology.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><p>This is a short transcript of a <a href="https://olejorik.github.io/talk/generic-programming-in-julia/">talk</a> given by me to my colleagues, explaining why I have worked on this package. It&#39;s kept as a blog item.</p><h1 id="AlternatingProjections.jl-(methodological-background)"><a class="docs-heading-anchor" href="#AlternatingProjections.jl-(methodological-background)">AlternatingProjections.jl (methodological background)</a><a id="AlternatingProjections.jl-(methodological-background)-1"></a><a class="docs-heading-anchor-permalink" href="#AlternatingProjections.jl-(methodological-background)" title="Permalink"></a></h1><p>The overall auto-pedagogical and methodological goal of the package is to learn Julia and to check whether it is indeed as suitable for mathematical programming as it is advertised.  So the package is written with the idea to keep its implementation as close to the mathematical or pseudocode description of the algorithms as possible.</p><p>In mathematics, the abstract concepts given by some definition and restrictive properties are often used. Similar concepts are often united in a single more general concept and so on. This idea of concepts hierarchy is reflected in Julia&#39;s <em>type system.</em> The package, on example of the alternating projections (AP) framework, introduces the main concepts of AP as hierarchy of types. Some of these implementations are obvious, some look artificial, and might be improved later, with the overall goal not the efficiency, but closeness to the mathematical text.</p><p>Consider, for instance, how you would explain to someone a method of alternating projections (see the previous chapter). By explaining it, you would mention concepts of sets, then you would mark some of them as feasible sets by requiring them to have some properties, for instance, being convex. Then you would explain what is the projection operation and how is it related to finding the closest point in the convex set. Then you would introduce the broad class of the alternating projections, specifying that here you will use its variant sometimes named as POCS (projections on the convex sets), and explain that the method proceeds iteratively and converges either to a feasible point or to a stable cycle of length 2 (for 2 sets). You would, most probably, mention that in practice the method is allowed to run for some fixed number of iterations or until the points get close enough to each other.</p><p>In this informal explanation one can extract however several important formal or abstract concepts.  These are of the feasible sets, convex sets as a particular case of feasible sets, concept of projection operator, abstract concept of a feasibility problem, and a concept of a method of alternating projections to solve it, with a particular subtype POCS and maybe a supertype of abstract &quot;algorithm&quot;. These abstract and particular concepts can be implemented in Julia as abstract and concrete types, but you might think why does ne need to do it, as the algorithm itself is quite straightforward to program in most languages. Well, the idea to do implement all the concepts in an abstract way has first of all the goal of generalisation. When you write these concepts on paper, it is helpful to see analogies and/or refer one problem to another class of the problems, so in the proof of some properties you might concentrate only on the proof of some small details specific to this type of problem.</p><p>The same should work also in the programming languages, I hope. For instance, suppose you want now to explain to someone Gerchberg-Saxton algorithm for phase retrieval problem. You might simply describe four simple steps of the algorithm, and it would remain some magic for your listener, or you can formulate it in the framework of feasibility problem, with slightly different type of the feasible sets and slightly different projection operations. With the same easiness it should be possible to be programmed ‚Äì we need just to  introduce another subtypes of the feasible sets and define the projection operation on them. And this is exactly wat the multiple dispatch feature of Julia does, so that&#39;s why I think it might be interesting to try to implement this in Julia. One additional reason, with several algorithms already implemented in one package, it would be easier to make quick experiments, like what if we use this algorithm to that sort of problem?  With proper hierarchies of abstract types for the feasible sets and the methods for the problem solutions, its should be easy.  </p><h2 id="Example-of-type-hierarchy:-FeasibleSet"><a class="docs-heading-anchor" href="#Example-of-type-hierarchy:-FeasibleSet">Example of type hierarchy: <code>FeasibleSet</code></a><a id="Example-of-type-hierarchy:-FeasibleSet-1"></a><a class="docs-heading-anchor-permalink" href="#Example-of-type-hierarchy:-FeasibleSet" title="Permalink"></a></h2><p>This concept is more or less clear. There is an abstract type FeasibleSet with subtypes of different types, like <code>ConvexSet</code> and further like <code>SupportConstrainedSet</code>, <code>AmplitudeConstrainedSet</code>, <em>etc.</em> All these should be abstract types.</p><p>Then we should be able to make some realisation  of these abstract sets.  The realisations should be implemented as concrete types, which cannot have any child types (the abstract types cannot have instantiations). This means that for an abstract type AmplitudeConstrainedSet we should have a concrete subtype, which should have some other name and which should contain some data related to a concrete implementation of the abstract concept. For instance, when in phase retrieval problem one specifies a set of all possible pupil fields with a <em>given</em> field amplitude <span>$a$</span> as  <span>$ùìê_a  = \{ x \in ‚ÑÇ^{N\times N} \ | \ |x| = a \}$</span> we can say that this is a structure named, for instance <code>AmplitudeConstrain(a)</code>, which is substantiation of a concrete type <code>AmplitudeConstrain</code>, which is, in turn, a subtype of abstract type <code>AmplitudeConstrainedSet</code>. This particular concrete type reflects just one of many possible ways of implementation of the amplitude constrain by specifying the point-wise absolute value of of a finite dimensional complex vector.</p><p>To better distinguish between the abstract and concrete types, in this package there is a convention to name the concrete types with other word order, namely a concrete subtype of abstract type <code>AmplitudeConstrainedSet</code> is named as <code>ConstrainedByAmplitude(a)</code>.</p><p>Then we can define a general phase retrieval problem as</p><pre><code class="nohighlight hljs">X = F x and 
x \in \aset &lt;: AmplitudeConstrainedSet,
X \in \Aset &lt;: AmplitudeConstrainedSet,</code></pre><p>and some concrete problem we want to solve as</p><pre><code class="nohighlight hljs">X = F x and 
x \in \aset &lt;: ConstrainedByAmplitude(a),
X \in \Aset &lt;: ConstrainedByAmplitude(A).</code></pre><p>Now the phase retrieval problem can be seen as a feasibility problem</p><p class="math-container">\[\text{find } x \in A \cap B, \ A = ùìê_A, \ B= F ùìê_a\]</p><h2 id="Problem-and-Algorithm-abstract-types"><a class="docs-heading-anchor" href="#Problem-and-Algorithm-abstract-types"><code>Problem</code>  and <code>Algorithm</code> abstract types</a><a id="Problem-and-Algorithm-abstract-types-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-and-Algorithm-abstract-types" title="Permalink"></a></h2><p>The package also introduces a special abstract type <code>Problem</code>, with concrete types as <code>FeasibilityProblem</code> and so on.  This introduction is done not so much for reflecting an abstract concept (althought this seems to be captured by this type as well) as for easiness of use. For instance, to solve a feasibility problem of finding <span>$x \in A\cap F^{-1} B$</span> with an AP method starting from some point <span>$x^0$</span>, with stopping criteria <code>maxit</code> and <code>maxœµ</code> one can write a function  <code>apsolve(A, B, F, F‚Åª¬π; x‚Å∞=zeros(size(A)), maxit = 20, maxœµ =0.01)</code>, but it seems to be much more elegant to group the first four arguments in one concept of <em>problem</em> and the last two being parameters of AP methods:</p><pre><code class="language-julia hljs">struct FeasibilityProblem &lt;: Problem
    A::FeasibleSet
    B::FeasibleSet
    forward
    backward
end</code></pre><p>and</p><pre><code class="language-julia hljs">struct AP &lt;: APMethod
    maxit
    maxœµ
end</code></pre><p>and the function looks both neater and more general now:</p><pre><code class="language-julia hljs">function solve(p::Problem,x‚Å∞,alg::APMethod)</code></pre><p>Thinking in the same logic as used when creating types for the feasible sets, we can create abstract types for the methods, something like <code>APMethods :&gt; POCS</code> <code>APMethods :&gt; GS</code> <code>APMethods : DR</code> and so on.</p><p>It is not however 100% clear what should belong to the concrete types. For instance, whether the backward and forward operations should belong to the method or to the set definition? On one hand, the definitions like <code>ConstrainedBySupport(a)</code> are valid only in some fixed basis, and thus the operations like forward and backward are only use to bring us to the basis where these operations are easier to perform (consider, for instacne, variant of TIP algorithm, where projection of the PSFs can be performed directly in the frequency domain, thus saving two <code>fft</code> operations). On the other hand, the operations like forward and inverse transforms in the GS algorithm, or, in much more extent, component-wise inversion of TIP algorithm, are binded to their names, and same GS without the Fourier transforms and TIP without inversions would be named just alternating projections. In addition, this simplifies the implementation of projections a little bit.</p><p>At the current moment, I have chosen to bind the forward and backward operations to the method definition, but the things might change with the future versions.</p><p>The initial and termination conditions (<code>initerm</code>) are not the part of the abstact method, but might be sought as part of a particular implementation. Then it is much like as with the feasible sets, and we can introduce the concrete types containing <code>initerm</code>.</p><h2 id="Function-solve"><a class="docs-heading-anchor" href="#Function-solve">Function <code>solve</code></a><a id="Function-solve-1"></a><a class="docs-heading-anchor-permalink" href="#Function-solve" title="Permalink"></a></h2><p>Now it is not difficult to write the implementation of the function <code>solve</code> for a  feasibility problem using AP method:</p><pre><code class="language-julia hljs">function solve(p::FeasibilityProblem, x‚Å∞, alg::AP)
    A = p.A
    B = p.B
    forward = p.forward
    backward = p.backward
    maxit = alg.maxit
    maxœµ =alg.maxœµ

    k = 0
    x·µè = x‚Å∞
    œµ = Inf

    while k &lt; maxit &amp;&amp; œµ &gt; maxœµ
        yÃÉ·µè = forward(x·µè)
        y·µè = project(yÃÉ·µè, B)
        xÃÉ·µè‚Å∫¬π = backward(y·µè)
        x·µè‚Å∫¬π = project(xÃÉ·µè‚Å∫¬π, A)
        œµ = LinearAlgebra.norm(x·µè‚Å∫¬π - x·µè)
        x·µè = x·µè‚Å∫¬π
    #         println(œµ)
        k += 1
    end

    println(&quot;To converge with $œµ accuracy, it took me $k iterations&quot;)
    return x·µè

end</code></pre><p>Note that here the first 6 lines of the code are just to save me some typing;  the code itself repeats literally the algorithm description. So this actually proves the statement of easiness of transfer of the math algorithms  in Julia. </p><h2 id="Function-project"><a class="docs-heading-anchor" href="#Function-project">Function <code>project</code></a><a id="Function-project-1"></a><a class="docs-heading-anchor-permalink" href="#Function-project" title="Permalink"></a></h2><p>Of course, to be able to use function <code>solve</code> from the previous section, we need to introduce the projections. And here, using the Julia&#39;s power of multiple dispatch, we can write teh implementations of projections only for the sets for which we know how to do it. This automatically implies the most general implementation as this:</p><pre><code class="language-julia hljs">function project(x, feasset::FeasibleSet)
    error(&quot;Don&#39;t know how to project on &quot;, typeof(feasset))
end</code></pre><p>This function does nothing but complains about its inabaility to do anything. But we can teach it to project on the <code>ConstrainedByAmplitude</code>, for instance:</p><pre><code class="language-julia hljs">function project(x, feasset::ConstrainedByAmplitude)
    return feasset.amp .* exp.( im * angle.(x))
end</code></pre><p>As you can see, the projection on this set only replaces the absolute value by that of  the constraint and keeps the argument.</p><p>Now we can check our just implemented AP method</p><pre><code class="language-julia hljs">y = zeros(ComplexF32,10,10)
y[1:5,1:5] = randn(ComplexF32, 5,5)
Y = fft(y)
p= FeasibilityProblem(ConstrainedByAmplitude(abs.(y)),ConstrainedByAmplitude(abs.(Y)),fft, ifft)
gs=AP(3000,1e-10)
z= solve(p, zeros(size(y)),gs)
abs.(z) ‚âà abs.(y)</code></pre><h2 id="Workflow-and-package-structure"><a class="docs-heading-anchor" href="#Workflow-and-package-structure">Workflow and package structure</a><a id="Workflow-and-package-structure-1"></a><a class="docs-heading-anchor-permalink" href="#Workflow-and-package-structure" title="Permalink"></a></h2><p>As the second goal of this project is to become more familiar with the programming in Julia, I log here my steps to create the &quot;workspace&quot;, like set up of IDE for the package and its documentation development and steps for creating and extending the package functionality. This log represents my personal and unexperienced experience, so it might be far from the ideal and not optimised.</p><h3 id="Development-workflow"><a class="docs-heading-anchor" href="#Development-workflow">Development workflow</a><a id="Development-workflow-1"></a><a class="docs-heading-anchor-permalink" href="#Development-workflow" title="Permalink"></a></h3><p>I&#39;m working in PyCharm with Julia plugin installed. The tests are located in <code>test\runtests.jl</code> file, which I can rerun using Shift+F10 shortcut. In the terminal window I have opened several terminals, one for compiling the documentation, another for starting Jupyter lab, another for running Julia repl.</p><p>I start Julia REPL in the terminal by julia command. It works because I have created a special folder <code>D:\Documents\bin</code>, added it to the Windows PATH variable and created there <code>julia.bat</code> file containing single line</p><pre><code class="language-commandline hljs">&quot;D:\Julia-1.2.0\bin\julia.exe&quot; %*</code></pre><p>Then in REPL (in package mode, press <code>]</code> to enter it) I activate the current environment with </p><pre><code class="language-julia hljs">activate .</code></pre><p>and start Revise typing </p><pre><code class="language-julia hljs">using Revise</code></pre><p>Then I try different things with the introduced by the package commands, modify the code, and save the best pieces in test files or in the demo notebooks or in the <code>runtests.jl</code>.</p><h3 id="Documentation-workflow"><a class="docs-heading-anchor" href="#Documentation-workflow">Documentation workflow</a><a id="Documentation-workflow-1"></a><a class="docs-heading-anchor-permalink" href="#Documentation-workflow" title="Permalink"></a></h3><p>in the second terminal window, in docs dirtectory, run </p><pre><code class="language-commandline hljs">julia make.jl</code></pre><p>In the third terminal window, also in the <code>docs</code> folder, issue</p><pre><code class="language-commandline hljs">python -m http.server --bind localhost</code></pre><p>Now the documentation can be seen in web browser by  http://127.0.0.1:8000/build/ url. Edit, save, run again <code>make.jl</code>, check the results in the browser. More info in the <a href="https://juliadocs.github.io/Documenter.jl/stable/man/guide/">docs of Documenter.jl.</a></p><h3 id="Package-structure"><a class="docs-heading-anchor" href="#Package-structure">Package structure</a><a id="Package-structure-1"></a><a class="docs-heading-anchor-permalink" href="#Package-structure" title="Permalink"></a></h3><p>Here are the steps I used to create the package <code>AlternatingProjections</code>.  I have decided to generate its initial structure with <a href="https://github.com/invenia/PkgTemplates.jl"><code>PkgTemplate</code> package</a>.</p><ol><li>Check the git configuration for the presence of the required fields (see <a href="https://invenia.github.io/PkgTemplates.jl/stable/#Usage-1">doc page</a> of <code>PkgTemplate</code>)</li></ol><pre><code class="language-commandline hljs">shell&gt; git config --global --list

...
user.name=Oleg Soloviev
user.email=oleg.soloviev@gmail.com
...
github.user=olejorik</code></pre><ol><li>open REPL, navigate to <code>Julia_learning</code> folder</li></ol><pre><code class="language-commandline hljs">    julia&gt; cd(&quot;..\\Documents\\Julia_learning\\&quot;)</code></pre><ol><li>Check installed packages (press <code>]</code> to enter package mode)</li></ol><pre><code class="language-commandline hljs">(v1.1) pkg&gt; st</code></pre><p>I don&#39;t have <code>PkgTemplates</code>, so I add it</p><pre><code class="language-commandline hljs">(v1.1) pkg&gt; add PkgTemplates
julia&gt; using PkgTemplates</code></pre><p>According to the description  https://github.com/invenia/PkgTemplates.jl, I make a template with the default values, but in the current directory current directory, and turning on SSH for git sync</p><pre><code class="language-commandline hljs">julia&gt; t = Template(; dir = &quot;.&quot;,ssh=true)
Template:
  ‚Üí User: olejorik
  ‚Üí Host: github.com
  ‚Üí License: MIT (Oleg Soloviev &lt;oleg.soloviev@gmail.com&gt; 2019)
  ‚Üí Package directory: D:\Documents\Julia_learning\
  ‚Üí Minimum Julia version: v1.0
  ‚Üí SSH remote: Yes
  ‚Üí Add packages to main environment: Yes
  ‚Üí Commit Manifest.toml: No
  ‚Üí Plugins: None</code></pre><pre><code class="language-commandline hljs">julia&gt; generate(&quot;AlternatingProjections&quot;, t)
Generating project AlternatingProjections:
    D:\Documents\Julia_learning\AlternatingProjections\Project.toml
    D:\Documents\Julia_learning\AlternatingProjections\src/AlternatingProjections.jl
[ Info: Initialized Git repo at D:\Documents\Julia_learning\AlternatingProjections
[ Info: Set remote origin to git@github.com:olejorik/AlternatingProjections.jl.git
Resolving package versions...
  Updating `D:\Documents\Julia_learning\AlternatingProjections\Project.toml`
  [8dfed614] + Test
  Updating `D:\Documents\Julia_learning\AlternatingProjections\Manifest.toml`
  [2a0f44e3] + Base64
  [8ba89e20] + Distributed
  [b77e0a4c] + InteractiveUtils
  [56ddb016] + Logging
  [d6f4376e] + Markdown
  [9a3f8284] + Random
  [9e88b42a] + Serialization
  [6462fe0b] + Sockets
  [8dfed614] + Test
  Updating registry at `C:\Users\Oleg\.julia\registries\General`
  Updating git-repo `https://github.com/JuliaRegistries/General.git`
Resolving package versions...
  Updating `D:\Documents\Julia_learning\AlternatingProjections\Project.toml`
[no changes]
  Updating `D:\Documents\Julia_learning\AlternatingProjections\Manifest.toml`
  [2a0f44e3] - Base64
  [8ba89e20] - Distributed
  [b77e0a4c] - InteractiveUtils
  [56ddb016] - Logging
  [d6f4376e] - Markdown
  [9a3f8284] - Random
  [9e88b42a] - Serialization
  [6462fe0b] - Sockets
  [8dfed614] - Test
[ Info: Committed 6 files/directories: src/, Project.toml, test/, README.md, LICENSE, .gitignore
Resolving package versions...
  Updating `C:\Users\Oleg\.julia\environments\v1.1\Project.toml`
  [37589ef0] + AlternatingProjections v0.1.0 [`D:\Documents\Julia_learning\AlternatingProjections`]
  Updating `C:\Users\Oleg\.julia\environments\v1.1\Manifest.toml`
  [37589ef0] + AlternatingProjections v0.1.0 [`D:\Documents\Julia_learning\AlternatingProjections`]
[ Info: New package is at D:\Documents\Julia_learning\AlternatingProjections
</code></pre><ol><li>Now we can cd to the project directory and activate it</li></ol><pre><code class="language-commandline hljs">julia&gt; cd(&quot;AlternatingProjections\\&quot;)
(v1.1) pkg&gt; activate .</code></pre><p>The status package shows installed packages</p><pre><code class="language-commandline hljs">(AlternatingProjections) pkg&gt; st
Project AlternatingProjections v0.1.0
    Status `D:\Documents\Julia_learning\AlternatingProjections\Project.toml`
  (no changes since last commit)</code></pre><p>In principle, I could run now </p><pre><code class="language-commandline hljs">] add FFTW</code></pre><p>but it&#39;s installed in the default environment, so I&#39;m not sure whether it is needed or not. I will do it for reproductibility and to add it to the required packages</p><pre><code class="language-commandline hljs">(AlternatingProjections) pkg&gt; add FFTW

(AlternatingProjections) pkg&gt; st
Project AlternatingProjections v0.1.0
    Status `D:\Documents\Julia_learning\AlternatingProjections\Project.toml`
  [7a1cc6ca] + FFTW v0.3.0
    Status `D:\Documents\Julia_learning\AlternatingProjections\Manifest.toml`
  [7a1cc6ca] + FFTW v0.3.0
</code></pre><ol><li>I will open the directory in Atom-Juno and/or in Pycharm. The former has nice integration with Julia, the latter has powerful editing features. In PyCharm, set the project interpreter to &quot;none&quot; (it&#39;s not a Python project)</li></ol><p>In Juno&#39;s Repl I activate the environment, load Revise package and load the just created AlternatingProjection package</p><pre><code class="language-commandline hljs">] activate.

julia&gt; using Revise
[ Info: Recompiling stale cache file C:\Users\Oleg\.julia\compiled\v1.1\Revise\M1Qoh.ji for Revise [295af30f-e4ad-537b-8983-00126c2a3abe]


julia&gt; using AlternatingProjections
[ Info: Precompiling AlternatingProjections [37589ef0-cc9c-11e9-2e35-d5d8b7f5a2df]</code></pre><p>I can check that the package is loaded by the greet function (not exported by default)</p><pre><code class="language-commandline hljs">julia&gt; AlternatingProjections.greet()
Hello World!</code></pre><p>To check the Revise package tracks the changes in the code, let&#39;s export the greet function by adding in <code>AlternatingProjections.jl</code> a line after the first line (module ..)</p><pre><code class="language-julia hljs">export greet</code></pre><p>and save the file. Now REPL should see <code>greet</code> function</p><pre><code class="language-commandline hljs">julia&gt; greet()
Hello World!
julia&gt; @which greet
AlternatingProjections</code></pre><p>The package is ready for the development.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">¬´ Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.18 on <span class="colophon-date" title="Thursday 26 May 2022 16:07">Thursday 26 May 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
