<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>AlternatingProjections.jl ¬∑ AlternatingProjections.jl</title><link rel="canonical" href="https://olejorik.github.io/AlternatingProjections.jl/stable/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>AlternatingProjections.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>AlternatingProjections.jl</a><ul class="internal"><li><a class="toctext" href="#Alternating-projections-(theoretical-background)-1">Alternating projections (theoretical background)</a></li><li><a class="toctext" href="#Forward-and-backward-operators-1">Forward and backward operators</a></li><li class="toplevel"><a class="toctext" href="#AlternatingProjections.jl-(methodological-background)-1">AlternatingProjections.jl (methodological background)</a></li><li><a class="toctext" href="#Example-of-type-hierarchy:-FeasibleSet-1">Example of type hierarchy: <code>FeasibleSet</code></a></li><li><a class="toctext" href="#Problem-and-Algorithm-abstract-types-1"><code>Problem</code>  and <code>Algorithm</code> abstract types</a></li><li><a class="toctext" href="#Function-solve-1">Function <code>solve</code></a></li><li><a class="toctext" href="#Function-project-1">Function <code>project</code></a></li><li><a class="toctext" href="#Workflow-and-package-structure-1">Workflow and package structure</a></li><li class="toplevel"><a class="toctext" href="#Package-features-1">Package features</a></li><li class="toplevel"><a class="toctext" href="#Manual-outline-1">Manual outline</a></li><li><a class="toctext" href="#Functions-1">Functions</a></li><li class="toplevel"><a class="toctext" href="#Index-1">Index</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>AlternatingProjections.jl</a></li></ul><a class="edit-page" href="https://github.com/olejorik/AlternatingProjections.jl/blob/master/docs/src/index.md"><span class="fa">ÔÇõ</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>AlternatingProjections.jl</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="AlternatingProjections.jl-1" href="#AlternatingProjections.jl-1">AlternatingProjections.jl</a></h1><p>A package implementing Alternating Projections methods in Julia.</p><h2><a class="nav-anchor" id="Alternating-projections-(theoretical-background)-1" href="#Alternating-projections-(theoretical-background)-1">Alternating projections (theoretical background)</a></h2><p>Alternating Projections (AP) is a simple method of solving a feasibility problem</p><div>\[\text{for sets } A, B,    \text{ find } x \in A \cap B\]</div><p>if <span>$A\cap B \neq \varnothing .$</span>  In case of inconsistent problem <span>$A\cap B = \varnothing$</span>, AP finds <span>$x \in A$</span>  closest to <span>$B$</span> in some sense.  </p><p>The algorithm starts with some initial value <span>$x^0$</span> and proceeds by projecting <span>$x^k$</span> alternatively on <span>$A$</span> and <span>$B$</span> :</p><div>\[y^{k} = P_B(x^k)\]</div><p>and</p><div>\[x^{k+1} = P_A(y^k).\]</div><p>The method was originally proposed by von Neumann in 1949 for <span>$A$</span> and <span>$B$</span> being linear subspaces, and was later generalised for any number of convex sets <span>$A_1, \ldots,A_N$</span> as</p><div>\[x^{k+1} = P_{A_{n(k)}}(x^k). \]</div><p>It was also recently shown that the method can also work for not convex sets, if the condition of <em>transversality</em> is satisfied, (see for instance the Gerchberg-Saxton method).</p><p>A lot of popular algorithms can be explained in AP framework,  even if the original algorithm was invented based on other principles. See, for instance, Gerchberg-Saxton algorithm for phase retrieval.</p><h3><a class="nav-anchor" id="Projections-1" href="#Projections-1">Projections</a></h3><p>Projection operator is often more easily described in math formula than in a computer program. It is easy to project on a (multidimensional) sphere, for instance, or to a polyhedron. The projection on a general convex set can be much more difficult (consider, for instance, projection on an ellipse). This explains why in this package we limit ourselves to special types of sets that allows relatively easiness  of defining a projection operator.</p><h2><a class="nav-anchor" id="Forward-and-backward-operators-1" href="#Forward-and-backward-operators-1">Forward and backward operators</a></h2><p>In some case the projection can be more easily computed in a transformed space (e.g. in the Fourier domain). This can be generalised further by introducing some abstract (even not necassarily linear) forward and backward transforms</p><div>\[x^{k+1} = b_{n(k)}(P_{A_{n(k)}}(f_{n(k)}(x^k))), \]</div><p>where <span>$f_{n(k)}(x)$</span> and <span>$b_{n(k)}(x)$</span> are the forward and backward transforms correspondingly. For instance, in TIP algorithm <span>$f(x) = b(x) = i /_* x$</span>, where <span>$/_*$</span> is &#39;&#39;deconvolution&#39;&#39; operator, such that  <span>$x /_* x = \delta_0$</span>.</p><h1><a class="nav-anchor" id="AlternatingProjections.jl-(methodological-background)-1" href="#AlternatingProjections.jl-(methodological-background)-1">AlternatingProjections.jl (methodological background)</a></h1><p>The overall auto-pedagogical and methodological goal of the package is to learn Julia and to check whether it is indeed as suitable for mathematical programming as it is advertised.  So the package is written with the idea to keep its implementation as close to the mathematical or pseudocode description of the algorithms as possible.</p><p>In mathematics, the abstract concepts given by some definition and restrictive properties are often used. Similar concepts are often united in a single more general concept and so on. This idea of concepts hierarchy is reflected in Julia&#39;s <em>type system.</em> The package, on example of the alternating projections (AP) framework, introduces the main concepts of AP as hierarchy of types. Some of these implementations are obvious, some look artificial, and might be improved later, with the overall goal not the efficiency, but closeness to the mathematical text.</p><p>Consider, for instance, how you would explain to someone a method of alternating projections (see the previous chapter). By explaining it, you would mention concepts of sets, then you would mark some of them as feasible sets by requiring them to have some properties, for instance, being convex. Then you would explain what is the projection operation and how is it related to finding the closest point in the convex set. Then you would introduce the broad class of the alternating projections, specifying that here you will use its variant sometimes named as POCS (projections on the convex sets), and explain that the method proceeds iteratively and converges either to a feasible point or to a stable cycle of length 2 (for 2 sets). You would, most probably, mention that in practice the method is allowed to run for some fixed number of iterations or until the points get close enough to each other.</p><p>In this informal explanation one can extract however several important formal or abstract concepts.  These are of the feasible sets, convex sets as a particular case of feasible sets, concept of projection operator, abstract concept of a feasibility problem, and a concept of a method of alternating projections to solve it, with a particular subtype POCS and maybe a supertype of abstract &quot;algorithm&quot;. These abstract and particular concepts can be implemented in Julia as abstract and concrete types, but you might think why does ne need to do it, as the algorithm itself is quite straightforward to program in most languages. Well, the idea to do implement all the concepts in an abstract way has first of all the goal of generalisation. When you write these concepts on paper, it is helpful to see analogies and/or refer one problem to another class of the problems, so in the proof of some properties you might concentrate only on the proof of some small details specific to this type of problem.</p><p>The same should work also in the programming languages, I hope. For instance, suppose you want now to explain to someone Gerchberg-Saxton algorithm for phase retrieval problem. You might simply describe four simple steps of the algorithm, and it would remain some magic for your listener, or you can formulate it in the framework of feasibility problem, with slightly different type of the feasible sets and slightly different projection operations. With the same easiness it should be possible to be programmed ‚Äì we need just to  introduce another subtypes of the feasible sets and define the projection operation on them. And this is exactly wat the multiple dispatch feature of Julia does, so that&#39;s why I think it might be interesting to try to implement this in Julia. One additional reason, with several algorithms already implemented in one package, it would be easier to make quick experiments, like what if we use this algorithm to that sort of problem?  With proper hierarchies of abstract types for the feasible sets and the methods for the problem solutions, its should be easy.  </p><h2><a class="nav-anchor" id="Example-of-type-hierarchy:-FeasibleSet-1" href="#Example-of-type-hierarchy:-FeasibleSet-1">Example of type hierarchy: <code>FeasibleSet</code></a></h2><p>This concept is more or less clear. There is an abstract type FeasibleSet with subtypes of different types, like <code>ConvexSet</code> and further like <code>SupportConstrainedSet</code>, <code>AmplitudeConstrainedSet</code>, <em>etc.</em> All these should be abstract types.</p><p>Then we should be able to make some realisation  of these abstract sets.  The realisations should be implemented as concrete types, which cannot have any child types (the abstract types cannot have instantiations). This means that for an abstract type AmplitudeConstrainedSet we should have a concrete subtype, which should have some other name and which should contain some data related to a concrete implementation of the abstract concept. For instance, when in phase retrieval problem one specifies a set of all possible pupil fields with a <em>given</em> field amplitude <span>$a$</span> as  <span>$ùìê_a  = \{ x \in ‚ÑÇ^{N\times N} \ | \ |x| = a \}$</span> we can say that this is a structure named, for instance <code>AmplitudeConstrain(a)</code>, which is substantiation of a concrete type <code>AmplitudeConstrain</code>, which is, in turn, a subtype of abstract type <code>AmplitudeConstrainedSet</code>. This particular concrete type reflects just one of many possible ways of implementation of the amplitude constrain by specifying the point-wise absolute value of of a finite dimensional complex vector.</p><p>To better distinguish between the abstract and concrete types, in this package there is a convention to name the concrete types with other word order, namely a concrete subtype of abstract type <code>AmplitudeConstrainedSet</code> is named as <code>ConstrainedByAmplitude(a)</code>.</p><p>Then we can define a general phase retrieval problem as</p><pre><code class="language-none">X = F x and 
x \in \aset &lt;: AmplitudeConstrainedSet,
X \in \Aset &lt;: AmplitudeConstrainedSet,</code></pre><p>and some concrete problem we want to solve as</p><pre><code class="language-none">X = F x and 
x \in \aset &lt;: ConstrainedByAmplitude(a),
X \in \Aset &lt;: ConstrainedByAmplitude(A).</code></pre><p>Now the phase retrieval problem can be seen as a feasibility problem</p><div>\[\text{find } x \in A \cap B, \ A = ùìê_A, \ B= F ùìê_a\]</div><h2><a class="nav-anchor" id="Problem-and-Algorithm-abstract-types-1" href="#Problem-and-Algorithm-abstract-types-1"><code>Problem</code>  and <code>Algorithm</code> abstract types</a></h2><p>The package also introduces a special abstract type <code>Problem</code>, with concrete types as <code>FeasibilityProblem</code> and so on.  This introduction is done not so much for reflecting an abstract concept (althought this seems to be captured by this type as well) as for easiness of use. For instance, to solve a feasibility problem of finding <span>$x \in A\cap F^{-1} B$</span> with an AP method starting from some point <span>$x^0$</span>, with stopping criteria <code>maxit</code> and <code>maxœµ</code> one can write a function  <code>apsolve(A, B, F, F‚Åª¬π; x‚Å∞=zeros(size(A)), maxit = 20, maxœµ =0.01)</code>, but it seems to be much more elegant to group the first four arguments in one concept of <em>problem</em> and the last two being parameters of AP methods:</p><pre><code class="language-julia">struct FeasibilityProblem &lt;: Problem
    A::FeasibleSet
    B::FeasibleSet
    forward
    backward
end</code></pre><p>and</p><pre><code class="language-julia">struct AP &lt;: APMethod
    maxit
    maxœµ
end</code></pre><p>and the function looks both neater and more general now:</p><pre><code class="language-julia">function solve(p::Problem,x‚Å∞,alg::APMethod)</code></pre><p>Thinking in the same logic as used when creating types for the feasible sets, we can create abstract types for the methods, something like <code>APMethods :&gt; POCS</code> <code>APMethods :&gt; GS</code> <code>APMethods : DR</code> and so on.</p><p>It is not however 100% clear what should belong to the concrete types. For instance, whether the backward and forward operations should belong to the method or to the set definition? On one hand, the definitions like <code>ConstrainedBySupport(a)</code> are valid only in some fixed basis, and thus the operations like forward and backward are only use to bring us to the basis where these operations are easier to perform (consider, for instacne, variant of TIP algorithm, where projection of the PSFs can be performed directly in the frequency domain, thus saving two <code>fft</code> operations). On the other hand, the operations like forward and inverse transforms in the GS algorithm, or, in much more extent, component-wise inversion of TIP algorithm, are binded to their names, and same GS without the Fourier transforms and TIP without inversions would be named just alternating projections. In addition, this simplifies the implementation of projections a little bit.</p><p>At the current moment, I have chosen to bind the forward and backward operations to the method definition, but the things might change with the future versions.</p><p>The initial and termination conditions (<code>initerm</code>) are not the part of the abstact method, but might be sought as part of a particular implementation. Then it is much like as with the feasible sets, and we can introduce the concrete types containing <code>initerm</code>.</p><h2><a class="nav-anchor" id="Function-solve-1" href="#Function-solve-1">Function <code>solve</code></a></h2><p>Now it is not difficult to write the implementation of the function <code>solve</code> for a  feasibility problem using AP method:</p><pre><code class="language-julia">function solve(p::FeasibilityProblem, x‚Å∞, alg::AP)
    A = p.A
    B = p.B
    forward = p.forward
    backward = p.backward
    maxit = alg.maxit
    maxœµ =alg.maxœµ

    k = 0
    x·µè = x‚Å∞
    œµ = Inf

    while k &lt; maxit &amp;&amp; œµ &gt; maxœµ
        yÃÉ·µè = forward(x·µè)
        y·µè = project(yÃÉ·µè, B)
        xÃÉ·µè‚Å∫¬π = backward(y·µè)
        x·µè‚Å∫¬π = project(xÃÉ·µè‚Å∫¬π, A)
        œµ = LinearAlgebra.norm(x·µè‚Å∫¬π - x·µè)
        x·µè = x·µè‚Å∫¬π
    #         println(œµ)
        k += 1
    end

    println(&quot;To converge with $œµ accuracy, it took me $k iterations&quot;)
    return x·µè

end</code></pre><p>Note that here the first 6 lines of the code are just to save me some typing;  the code itself repeats literally the algorithm description. So this actually proves the statement of easiness of transfer of the math algorithms  in Julia. </p><h2><a class="nav-anchor" id="Function-project-1" href="#Function-project-1">Function <code>project</code></a></h2><p>Of course, to be able to use function <code>solve</code> from the previous section, we need to introduce the projections. And here, using the Julia&#39;s power of multiple dispatch, we can write teh implementations of projections only for the sets for which we know how to do it. This automatically implies the most general implementation as this:</p><pre><code class="language-julia">function project(x, feasset::FeasibleSet)
    error(&quot;Don&#39;t know how to project on &quot;, typeof(feasset))
end</code></pre><p>This function does nothing but complains about its inabaility to do anything. But we can teach it to project on the <code>ConstrainedByAmplitude</code>, for instance:</p><pre><code class="language-julia">function project(x, feasset::ConstrainedByAmplitude)
    return feasset.amp .* exp.( im * angle.(x))
end</code></pre><p>As you can see, the projection on this set only replaces the absolute value by that of  the constraint and keeps the argument.</p><p>Now we can check our just implemented AP method</p><pre><code class="language-julia">y = zeros(ComplexF32,10,10)
y[1:5,1:5] = randn(ComplexF32, 5,5)
Y = fft(y)
p= FeasibilityProblem(ConstrainedByAmplitude(abs.(y)),ConstrainedByAmplitude(abs.(Y)),fft, ifft)
gs=AP(3000,1e-10)
z= solve(p, zeros(size(y)),gs)
abs.(z) ‚âà abs.(y)</code></pre><h2><a class="nav-anchor" id="Workflow-and-package-structure-1" href="#Workflow-and-package-structure-1">Workflow and package structure</a></h2><p>As the second goal of this project is to become more familiar with the programming in Julia, I log here my steps to create the &quot;workspace&quot;, like set up of IDE for the package and its documentation development and steps for creating and extending the package functionality. This log represents my personal and unexperienced experience, so it might be far from the ideal and not optimised.</p><h3><a class="nav-anchor" id="Development-workflow-1" href="#Development-workflow-1">Development workflow</a></h3><p>I&#39;m working in PyCharm with Julia plugin installed. The tests are located in <code>test\runtests.jl</code> file, which I can rerun using Shift+F10 shortcut. In the terminal window I have opened several terminals, one for compiling the documentation, another for starting Jupyter lab, another for running Julia repl.</p><p>I start Julia REPL in the terminal by julia command. It works because I have created a special folder <code>D:\Documents\bin</code>, added it to the Windows PATH variable and created there <code>julia.bat</code> file containing single line</p><pre><code class="language-commandline">&quot;D:\Julia-1.2.0\bin\julia.exe&quot; %*</code></pre><p>Then in REPL (in package mode, press <code>]</code> to enter it) I activate the current environment with </p><pre><code class="language-julia">activate .</code></pre><p>and start Revise typing </p><pre><code class="language-julia">using Revise</code></pre><p>Then I try different things with the introduced by the package commands, modify the code, and save the best pieces in test files or in the demo notebooks or in the <code>runtests.jl</code>.</p><h3><a class="nav-anchor" id="Documentation-workflow-1" href="#Documentation-workflow-1">Documentation workflow</a></h3><p>in the second terminal window, in docs dirtectory, run </p><pre><code class="language-commandline">julia make.jl</code></pre><p>In the third terminal window, also in the <code>docs</code> folder, issue</p><pre><code class="language-commandline">python -m http.server --bind localhost</code></pre><p>Now the documentation can be seen in web browser by  http://127.0.0.1:8000/build/ url. Edit, save, run again <code>make.jl</code>, check the results in the browser. More info in the <a href="https://juliadocs.github.io/Documenter.jl/stable/man/guide/">docs of Documenter.jl.</a></p><h3><a class="nav-anchor" id="Package-structure-1" href="#Package-structure-1">Package structure</a></h3><p>Here are the steps I used to create the package <code>AlternatingProjections</code>.  I have decided to generate its initial structure with <a href="https://github.com/invenia/PkgTemplates.jl"><code>PkgTemplate</code> package</a>.</p><ol><li>Check the git configuration for the presence of the required fields (see <a href="https://invenia.github.io/PkgTemplates.jl/stable/#Usage-1">doc page</a> of <code>PkgTemplate</code>)</li></ol><pre><code class="language-commandline">shell&gt; git config --global --list

...
user.name=Oleg Soloviev
user.email=oleg.soloviev@gmail.com
...
github.user=olejorik</code></pre><ol><li>open REPL, navigate to <code>Julia_learning</code> folder</li></ol><pre><code class="language-commandline">    julia&gt; cd(&quot;..\\Documents\\Julia_learning\\&quot;)</code></pre><ol><li>Check installed packages (press <code>]</code> to enter package mode)</li></ol><pre><code class="language-commandline">(v1.1) pkg&gt; st</code></pre><p>I don&#39;t have <code>PkgTemplates</code>, so I add it</p><pre><code class="language-commandline">(v1.1) pkg&gt; add PkgTemplates
julia&gt; using PkgTemplates</code></pre><p>According to the description  https://github.com/invenia/PkgTemplates.jl, I make a template with the default values, but in the current directory current directory, and turning on SSH for git sync</p><pre><code class="language-commandline">julia&gt; t = Template(; dir = &quot;.&quot;,ssh=true)
Template:
  ‚Üí User: olejorik
  ‚Üí Host: github.com
  ‚Üí License: MIT (Oleg Soloviev &lt;oleg.soloviev@gmail.com&gt; 2019)
  ‚Üí Package directory: D:\Documents\Julia_learning\
  ‚Üí Minimum Julia version: v1.0
  ‚Üí SSH remote: Yes
  ‚Üí Add packages to main environment: Yes
  ‚Üí Commit Manifest.toml: No
  ‚Üí Plugins: None</code></pre><pre><code class="language-commandline">julia&gt; generate(&quot;AlternatingProjections&quot;, t)
Generating project AlternatingProjections:
    D:\Documents\Julia_learning\AlternatingProjections\Project.toml
    D:\Documents\Julia_learning\AlternatingProjections\src/AlternatingProjections.jl
[ Info: Initialized Git repo at D:\Documents\Julia_learning\AlternatingProjections
[ Info: Set remote origin to git@github.com:olejorik/AlternatingProjections.jl.git
Resolving package versions...
  Updating `D:\Documents\Julia_learning\AlternatingProjections\Project.toml`
  [8dfed614] + Test
  Updating `D:\Documents\Julia_learning\AlternatingProjections\Manifest.toml`
  [2a0f44e3] + Base64
  [8ba89e20] + Distributed
  [b77e0a4c] + InteractiveUtils
  [56ddb016] + Logging
  [d6f4376e] + Markdown
  [9a3f8284] + Random
  [9e88b42a] + Serialization
  [6462fe0b] + Sockets
  [8dfed614] + Test
  Updating registry at `C:\Users\Oleg\.julia\registries\General`
  Updating git-repo `https://github.com/JuliaRegistries/General.git`
Resolving package versions...
  Updating `D:\Documents\Julia_learning\AlternatingProjections\Project.toml`
[no changes]
  Updating `D:\Documents\Julia_learning\AlternatingProjections\Manifest.toml`
  [2a0f44e3] - Base64
  [8ba89e20] - Distributed
  [b77e0a4c] - InteractiveUtils
  [56ddb016] - Logging
  [d6f4376e] - Markdown
  [9a3f8284] - Random
  [9e88b42a] - Serialization
  [6462fe0b] - Sockets
  [8dfed614] - Test
[ Info: Committed 6 files/directories: src/, Project.toml, test/, README.md, LICENSE, .gitignore
Resolving package versions...
  Updating `C:\Users\Oleg\.julia\environments\v1.1\Project.toml`
  [37589ef0] + AlternatingProjections v0.1.0 [`D:\Documents\Julia_learning\AlternatingProjections`]
  Updating `C:\Users\Oleg\.julia\environments\v1.1\Manifest.toml`
  [37589ef0] + AlternatingProjections v0.1.0 [`D:\Documents\Julia_learning\AlternatingProjections`]
[ Info: New package is at D:\Documents\Julia_learning\AlternatingProjections
</code></pre><ol><li>Now we can cd to the project directory and activate it</li></ol><pre><code class="language-commandline">julia&gt; cd(&quot;AlternatingProjections\\&quot;)
(v1.1) pkg&gt; activate .</code></pre><p>The status package shows installed packages</p><pre><code class="language-commandline">(AlternatingProjections) pkg&gt; st
Project AlternatingProjections v0.1.0
    Status `D:\Documents\Julia_learning\AlternatingProjections\Project.toml`
  (no changes since last commit)</code></pre><p>In principle, I could run now </p><pre><code class="language-commandline">] add FFTW</code></pre><p>but it&#39;s installed in the default environment, so I&#39;m not sure whether it is needed or not. I will do it for reproductibility and to add it to the required packages</p><pre><code class="language-commandline">(AlternatingProjections) pkg&gt; add FFTW

(AlternatingProjections) pkg&gt; st
Project AlternatingProjections v0.1.0
    Status `D:\Documents\Julia_learning\AlternatingProjections\Project.toml`
  [7a1cc6ca] + FFTW v0.3.0
    Status `D:\Documents\Julia_learning\AlternatingProjections\Manifest.toml`
  [7a1cc6ca] + FFTW v0.3.0
</code></pre><ol><li>I will open the directory in Atom-Juno and/or in Pycharm. The former has nice integration with Julia, the latter has powerful editing features. In PyCharm, set the project interpreter to &quot;none&quot; (it&#39;s not a Python project)</li></ol><p>In Juno&#39;s Repl I activate the environment, load Revise package and load the just created AlternatingProjection package</p><pre><code class="language-commandline">] activate.

julia&gt; using Revise
[ Info: Recompiling stale cache file C:\Users\Oleg\.julia\compiled\v1.1\Revise\M1Qoh.ji for Revise [295af30f-e4ad-537b-8983-00126c2a3abe]


julia&gt; using AlternatingProjections
[ Info: Precompiling AlternatingProjections [37589ef0-cc9c-11e9-2e35-d5d8b7f5a2df]</code></pre><p>I can check that the package is loaded by the greet function (not exported by default)</p><pre><code class="language-commandline">julia&gt; AlternatingProjections.greet()
Hello World!</code></pre><p>To check the Revise package tracks the changes in the code, let&#39;s export the greet function by adding in <code>AlternatingProjections.jl</code> a line after the first line (module ..)</p><pre><code class="language-julia">export greet</code></pre><p>and save the file. Now REPL should see <code>greet</code> function</p><pre><code class="language-commandline">julia&gt; greet()
Hello World!
julia&gt; @which greet
AlternatingProjections</code></pre><p>The package is ready for the development.</p><h1><a class="nav-anchor" id="Package-features-1" href="#Package-features-1">Package features</a></h1><ul><li>types for the frequently used feasible sets and projections on them</li><li>a general AP algorithm and examples of its adaptation to popular AP algorithms, including:<a href="#footnote-1">[1]</a><ul><li>Gerchberg-Saxton</li><li><em>Vector Gerchberg-Saxton</em></li><li><em>Gerchberg-Papoulis</em></li><li>TIP</li><li><em>Douglas‚ÄìRachford</em></li><li><em>DRAP</em></li></ul></li></ul><div class="footnote" id="footnote-1"><a href="#footnote-1"><strong>[1]</strong></a><p>not implemented features are shown with italics</p></div><h1><a class="nav-anchor" id="Manual-outline-1" href="#Manual-outline-1">Manual outline</a></h1><ul><li><a href="#AlternatingProjections.jl-1">AlternatingProjections.jl</a></li><ul><li><a href="#Alternating-projections-(theoretical-background)-1">Alternating projections (theoretical background)</a></li><li><a href="#Forward-and-backward-operators-1">Forward and backward operators</a></li></ul><li><a href="#AlternatingProjections.jl-(methodological-background)-1">AlternatingProjections.jl (methodological background)</a></li><ul><li><a href="#Example-of-type-hierarchy:-FeasibleSet-1">Example of type hierarchy: <code>FeasibleSet</code></a></li><li><a href="#Problem-and-Algorithm-abstract-types-1"><code>Problem</code>  and <code>Algorithm</code> abstract types</a></li><li><a href="#Function-solve-1">Function <code>solve</code></a></li><li><a href="#Function-project-1">Function <code>project</code></a></li><li><a href="#Workflow-and-package-structure-1">Workflow and package structure</a></li></ul><li><a href="#Package-features-1">Package features</a></li><li><a href="#Manual-outline-1">Manual outline</a></li><ul><li><a href="#Functions-1">Functions</a></li></ul><li><a href="#Index-1">Index</a></li></ul><h2><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AlternatingProjections.project-Tuple{Any,FeasibleSet}" href="#AlternatingProjections.project-Tuple{Any,FeasibleSet}"><code>AlternatingProjections.project</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">project(x, A)</code></pre><p>Project <code>x</code> on set <code>A</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/olejorik/AlternatingProjections.jl/blob/3ba0cb095d92d05df961e7a070d0b206069cba64/src/AlternatingProjections.jl#L79-L83">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AlternatingProjections.solve-Tuple{FeasibilityProblem,Any,AP}" href="#AlternatingProjections.solve-Tuple{FeasibilityProblem,Any,AP}"><code>AlternatingProjections.solve</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">solve(p::Problem,x‚Å∞,alg::APMethod)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/olejorik/AlternatingProjections.jl/blob/3ba0cb095d92d05df961e7a070d0b206069cba64/src/AlternatingProjections.jl#L103-L113">source</a></section><h3><a class="nav-anchor" id="Types-1" href="#Types-1">Types</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AlternatingProjections.FeasibleSet" href="#AlternatingProjections.FeasibleSet"><code>AlternatingProjections.FeasibleSet</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">FeasibleSet</code></pre><p>Abstract type representing a set for feasibility problem.</p></div></div><a class="source-link" target="_blank" href="https://github.com/olejorik/AlternatingProjections.jl/blob/3ba0cb095d92d05df961e7a070d0b206069cba64/src/AlternatingProjections.jl#L53-L57">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AlternatingProjections.ConvexSet" href="#AlternatingProjections.ConvexSet"><code>AlternatingProjections.ConvexSet</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ConvexSet</code></pre><p>General type, no projection method is specified.</p><p><strong>Examples</strong></p><pre><code class="language-julia"></code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/olejorik/AlternatingProjections.jl/blob/3ba0cb095d92d05df961e7a070d0b206069cba64/src/AlternatingProjections.jl#L62-L71">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AlternatingProjections.AmplitudeConstrainedSet" href="#AlternatingProjections.AmplitudeConstrainedSet"><code>AlternatingProjections.AmplitudeConstrainedSet</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p><strong>type AmplitudeConstraint</strong></p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/olejorik/AlternatingProjections.jl/blob/3ba0cb095d92d05df961e7a070d0b206069cba64/src/AmplitudeConstraint.jl#L1-L10">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AlternatingProjections.ConstrainedBySupport" href="#AlternatingProjections.ConstrainedBySupport"><code>AlternatingProjections.ConstrainedBySupport</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p><strong>ConstrainedBySupport(support)</strong></p><p>Special type of convex set.</p><p>For continuous case: consists of all functions that equals zero outside some fixed area called support: <span>$ùìê_S = \{f : f(x) = 0, x ‚àâ S \} .$</span></p><p>For discrete case: all arrays that equals zero for indexes outside some index set: <span>$ùìê_S = \{x : x[i] = 0, i ‚àâ S \} .$</span></p><p>Currently supports only discrete case, with the support defined as a boolean array.</p><ul><li>Julia version: </li><li>Author: Oleg Soloviev</li><li>Date: 2019-09-01</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">
julia&gt; S =  ConstrainedBySupport([true, false,true])
ConstrainedBySupport(Bool[true, false, true])

julia&gt; x = [1, 2, 3]; project(x, S)
3-element Array{Int64,1}:
 1
 0
 3

julia&gt; S = ConstrainedBySupport([x^2 + y^2 &lt;=1  for x in -2:.2:2, y in -2:.2:2]);
julia&gt; x = ones(size(S.support));
julia&gt; project(x,S)
21√ó21 Array{Float64,2}:
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/olejorik/AlternatingProjections.jl/blob/3ba0cb095d92d05df961e7a070d0b206069cba64/src/SupportConstraint.jl#L3-L60">source</a></section><h1><a class="nav-anchor" id="Index-1" href="#Index-1">Index</a></h1><ul><li><a href="#AlternatingProjections.AmplitudeConstrainedSet"><code>AlternatingProjections.AmplitudeConstrainedSet</code></a></li><li><a href="#AlternatingProjections.ConstrainedBySupport"><code>AlternatingProjections.ConstrainedBySupport</code></a></li><li><a href="#AlternatingProjections.ConvexSet"><code>AlternatingProjections.ConvexSet</code></a></li><li><a href="#AlternatingProjections.FeasibleSet"><code>AlternatingProjections.FeasibleSet</code></a></li><li><a href="#AlternatingProjections.project-Tuple{Any,FeasibleSet}"><code>AlternatingProjections.project</code></a></li><li><a href="#AlternatingProjections.solve-Tuple{FeasibilityProblem,Any,AP}"><code>AlternatingProjections.solve</code></a></li></ul><footer><hr/></footer></article></body></html>
