<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · AlternatingProjections.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://olejorik.github.io/AlternatingProjections.jl/stable/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>AlternatingProjections.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Alternating-projections-(theoretical-background)"><span>Alternating projections (theoretical background)</span></a></li><li><a class="tocitem" href="#Forward-and-backward-operators"><span>Forward and backward operators</span></a></li><li class="toplevel"><a class="tocitem" href="#Package-features"><span>Package features</span></a></li><li class="toplevel"><a class="tocitem" href="#Manual-outline"><span>Manual outline</span></a></li><li class="toplevel"><a class="tocitem" href="#Function-Index"><span>Function Index</span></a></li><li><a class="tocitem" href="#AlternatingProjections"><span>AlternatingProjections</span></a></li><li><a class="tocitem" href="#AbstractProblems"><span>AbstractProblems</span></a></li><li class="toplevel"><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li><li><a class="tocitem" href="methodology/">Second purpose of this package</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/olejorik/AlternatingProjections.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="AlternatingProjections.jl"><a class="docs-heading-anchor" href="#AlternatingProjections.jl">AlternatingProjections.jl</a><a id="AlternatingProjections.jl-1"></a><a class="docs-heading-anchor-permalink" href="#AlternatingProjections.jl" title="Permalink"></a></h1><p>A package implementing Alternating Projections methods in Julia.</p><h2 id="Alternating-projections-(theoretical-background)"><a class="docs-heading-anchor" href="#Alternating-projections-(theoretical-background)">Alternating projections (theoretical background)</a><a id="Alternating-projections-(theoretical-background)-1"></a><a class="docs-heading-anchor-permalink" href="#Alternating-projections-(theoretical-background)" title="Permalink"></a></h2><p>Alternating Projections (AP) is a simple method of solving a feasibility problem</p><p class="math-container">\[\text{for sets } A, B,    \text{ find } x \in A \cap B\]</p><p>if <span>$A\cap B \neq \varnothing .$</span>  In case of inconsistent problem <span>$A\cap B = \varnothing$</span>, AP finds <span>$x \in A$</span>  closest to <span>$B$</span> in some sense.  </p><p>The algorithm starts with some initial value <span>$x^0$</span> and proceeds by projecting <span>$x^k$</span> alternatively on <span>$A$</span> and <span>$B$</span> :</p><p class="math-container">\[y^{k} = P_B(x^k)\]</p><p>and</p><p class="math-container">\[x^{k+1} = P_A(y^k).\]</p><p>The method was originally proposed by von Neumann in 1949 for <span>$A$</span> and <span>$B$</span> being linear subspaces, and was later generalised for any number of convex sets <span>$A_1, \ldots,A_N$</span> as</p><p class="math-container">\[x^{k+1} = P_{A_{n(k)}}(x^k). \]</p><p>It was also recently shown that the method can also work for not convex sets, if the condition of <em>transversality</em> is satisfied, (see for instance the Gerchberg-Saxton method).</p><p>A lot of popular algorithms can be explained in AP framework,  even if the original algorithm was invented based on other principles. See, for instance, Gerchberg-Saxton algorithm for phase retrieval.</p><h3 id="Projections"><a class="docs-heading-anchor" href="#Projections">Projections</a><a id="Projections-1"></a><a class="docs-heading-anchor-permalink" href="#Projections" title="Permalink"></a></h3><p>Projection operator is often more easily described in math formula than in a computer program. It is easy to project on a (multidimensional) sphere, for instance, or to a polyhedron. The projection on a general convex set can be much more difficult (consider, for instance, projection on an ellipse). This explains why in this package we limit ourselves to special types of sets that allows relatively easiness  of defining a projection operator.</p><h2 id="Forward-and-backward-operators"><a class="docs-heading-anchor" href="#Forward-and-backward-operators">Forward and backward operators</a><a id="Forward-and-backward-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Forward-and-backward-operators" title="Permalink"></a></h2><p>In some case the projection can be more easily computed in a transformed space (e.g. in the Fourier domain). This can be generalised further by introducing some abstract (even not necassarily linear) forward and backward transforms</p><p class="math-container">\[x^{k+1} = b_{n(k)}(P_{A_{n(k)}}(f_{n(k)}(x^k))), \]</p><p>where <span>$f_{n(k)}(x)$</span> and <span>$b_{n(k)}(x)$</span> are the forward and backward transforms correspondingly. For instance, in TIP algorithm <span>$f(x) = b(x) = i /_* x$</span>, where <span>$/_*$</span> is &#39;&#39;deconvolution&#39;&#39; operator, such that  <span>$x /_* x = \delta_0$</span>.</p><h1 id="Package-features"><a class="docs-heading-anchor" href="#Package-features">Package features</a><a id="Package-features-1"></a><a class="docs-heading-anchor-permalink" href="#Package-features" title="Permalink"></a></h1><ul><li>types for the frequently used feasible sets and projections on them</li><li>a general AP algorithm and examples of its adaptation to popular AP algorithms, including:<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup><ul><li>Gerchberg-Saxton</li><li><em>Vector Gerchberg-Saxton</em></li><li><em>Gerchberg-Papoulis</em></li><li><em>TIP</em></li><li>Douglas–Rachford</li><li>DRAP</li></ul></li></ul><h1 id="Manual-outline"><a class="docs-heading-anchor" href="#Manual-outline">Manual outline</a><a id="Manual-outline-1"></a><a class="docs-heading-anchor-permalink" href="#Manual-outline" title="Permalink"></a></h1><ul><li><a href="#AlternatingProjections.jl">AlternatingProjections.jl</a></li><li class="no-marker"><ul><li><a href="#Alternating-projections-(theoretical-background)">Alternating projections (theoretical background)</a></li><li><a href="#Forward-and-backward-operators">Forward and backward operators</a></li></ul></li><li><a href="#Package-features">Package features</a></li><li><a href="#Manual-outline">Manual outline</a></li><li><a href="#Function-Index">Function Index</a></li><li class="no-marker"><ul><li><a href="#AlternatingProjections">AlternatingProjections</a></li><li><a href="#AbstractProblems">AbstractProblems</a></li></ul></li><li><a href="#Index">Index</a></li><li><a href="methodology/#AlternatingProjections.jl-(methodological-background)">AlternatingProjections.jl (methodological background)</a></li><li class="no-marker"><ul><li><a href="methodology/#Example-of-type-hierarchy:-FeasibleSet">Example of type hierarchy: <code>FeasibleSet</code></a></li><li><a href="methodology/#Problem-and-Algorithm-abstract-types"><code>Problem</code>  and <code>Algorithm</code> abstract types</a></li><li><a href="methodology/#Function-solve">Function <code>solve</code></a></li><li><a href="methodology/#Function-project">Function <code>project</code></a></li><li><a href="methodology/#Workflow-and-package-structure">Workflow and package structure</a></li></ul></li></ul><h1 id="Function-Index"><a class="docs-heading-anchor" href="#Function-Index">Function Index</a><a id="Function-Index-1"></a><a class="docs-heading-anchor-permalink" href="#Function-Index" title="Permalink"></a></h1><h2 id="AlternatingProjections"><a class="docs-heading-anchor" href="#AlternatingProjections">AlternatingProjections</a><a id="AlternatingProjections-1"></a><a class="docs-heading-anchor-permalink" href="#AlternatingProjections" title="Permalink"></a></h2><p>The types defined here are absract and not related exclusevely to the alternating projections methos.</p><article class="docstring"><header><a class="docstring-binding" id="AlternatingProjections" href="#AlternatingProjections"><code>AlternatingProjections</code></a> — <span class="docstring-category">Module</span></header><section><div><p>AlternatingProjections</p><p>Module contains types and functions for formulation and solving feasibility problem     using projections-based methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/olejorik/AlternatingProjections.jl/blob/1bb4f87c979af6c2afc8a0508a9c358c857bb313/src/AlternatingProjections.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AlternatingProjections.forward!-Tuple{TransformedSet}" href="#AlternatingProjections.forward!-Tuple{TransformedSet}"><code>AlternatingProjections.forward!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>forward!(ts::TransformedSet)</p><p>In-place forward transform assosiated with the set <code>ts</code>: <code>x ∈ ts ⇔ f(x) ∈ ts.set</code> Use <code>forward!(ts)(q,p)</code> to obtain <code>q = f(p)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/olejorik/AlternatingProjections.jl/blob/1bb4f87c979af6c2afc8a0508a9c358c857bb313/src/TransformedSet.jl#L14-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AlternatingProjections.project!-Tuple{Any, Any, FeasibleSet}" href="#AlternatingProjections.project!-Tuple{Any, Any, FeasibleSet}"><code>AlternatingProjections.project!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project!(xp, x, A)</code></pre><p>Project <code>x</code> on set <code>A</code> using preallocated <code>xp</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/olejorik/AlternatingProjections.jl/blob/1bb4f87c979af6c2afc8a0508a9c358c857bb313/src/AlternatingProjections.jl#L72-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AlternatingProjections.project!-Tuple{Any, FeasibleSet}" href="#AlternatingProjections.project!-Tuple{Any, FeasibleSet}"><code>AlternatingProjections.project!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project!(x, A)</code></pre><p>Project <code>x</code> on set <code>A</code> and storing result in <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/olejorik/AlternatingProjections.jl/blob/1bb4f87c979af6c2afc8a0508a9c358c857bb313/src/AlternatingProjections.jl#L81-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AlternatingProjections.project-Tuple{Any, FeasibleSet}" href="#AlternatingProjections.project-Tuple{Any, FeasibleSet}"><code>AlternatingProjections.project</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project(x, A)</code></pre><p>Project <code>x</code> on set <code>A</code> and return the result of projection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/olejorik/AlternatingProjections.jl/blob/1bb4f87c979af6c2afc8a0508a9c358c857bb313/src/AlternatingProjections.jl#L90-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AlternatingProjections.reflect!-Tuple{Any, Any, FeasibleSet}" href="#AlternatingProjections.reflect!-Tuple{Any, Any, FeasibleSet}"><code>AlternatingProjections.reflect!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reflect!(xr, x, A)</code></pre><p>Reflect <code>x</code> on set <code>A</code> using preallocated <code>xp</code>, R(x) = 2P(x) -x, where P is projection on the set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/olejorik/AlternatingProjections.jl/blob/1bb4f87c979af6c2afc8a0508a9c358c857bb313/src/AlternatingProjections.jl#L99-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AlternatingProjections.ACset" href="#AlternatingProjections.ACset"><code>AlternatingProjections.ACset</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ACset{T,N,M,K}(amp,projdims)</code></pre><p>Constructs an extended version of the AmplitudeCosntrained set. Here, <code>amp</code> can be a tuple of amplitudes, and <code>projdims</code> are the dimeshoins, along with the length of the vector is measured.</p><p>TODO extend description</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/olejorik/AlternatingProjections.jl/blob/1bb4f87c979af6c2afc8a0508a9c358c857bb313/src/AmplitudeConstraint.jl#L44-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AlternatingProjections.AP" href="#AlternatingProjections.AP"><code>AlternatingProjections.AP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AP &lt;: ProjectionsMethod</code></pre><p>Classical Alternating Projections method</p><p>Project on one set, than on another, stop after fixed number of iterations or if the desired accuracy is achieved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/olejorik/AlternatingProjections.jl/blob/1bb4f87c979af6c2afc8a0508a9c358c857bb313/src/AP.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AlternatingProjections.AmplitudeConstrainedSet" href="#AlternatingProjections.AmplitudeConstrainedSet"><code>AlternatingProjections.AmplitudeConstrainedSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AmplitudeConstrainedSet</code></pre><p>Abstract set of complex-values <code>x</code> with a given absolute value <code>|x| = amp</code>. The amplitude can be extracted by function <code>amp</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/olejorik/AlternatingProjections.jl/blob/1bb4f87c979af6c2afc8a0508a9c358c857bb313/src/AmplitudeConstraint.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AlternatingProjections.ConstrainedByAmplitude" href="#AlternatingProjections.ConstrainedByAmplitude"><code>AlternatingProjections.ConstrainedByAmplitude</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConstrainedByAmplitude{T,N}</code></pre><p>Set of abstract arryas with element type <code>T</code> and dimensions <code>N</code> defined by the amplitude constraint <code>|x| = amp</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/olejorik/AlternatingProjections.jl/blob/1bb4f87c979af6c2afc8a0508a9c358c857bb313/src/AmplitudeConstraint.jl#L13-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AlternatingProjections.ConstrainedByAmplitude-Union{Tuple{AbstractArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}" href="#AlternatingProjections.ConstrainedByAmplitude-Union{Tuple{AbstractArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}"><code>AlternatingProjections.ConstrainedByAmplitude</code></a> — <span class="docstring-category">Method</span></header><section><div><p>ConstrainedByAmplitude(a::AbstractArray{T,N})</p><p>Construct set defined by the amplitude constraint <code>|x| = a</code>. Type and dimension of the set are inhereited from the array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/olejorik/AlternatingProjections.jl/blob/1bb4f87c979af6c2afc8a0508a9c358c857bb313/src/AmplitudeConstraint.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AlternatingProjections.ConstrainedByAmplitudeMasked" href="#AlternatingProjections.ConstrainedByAmplitudeMasked"><code>AlternatingProjections.ConstrainedByAmplitudeMasked</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConstrainedByAmplitudeMasked(a, mask::Vector{CartesianIndex{N}})
ConstrainedByAmplitudeMasked(a, AbstractArray{Bool})</code></pre><p>The amplitude constrained set only in the indexes given by mask:  <code>|xᵢ| = aᵢ</code> for <code>i ∈ mask</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/olejorik/AlternatingProjections.jl/blob/1bb4f87c979af6c2afc8a0508a9c358c857bb313/src/AmplitudeConstraint.jl#L68-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AlternatingProjections.ConstrainedByShape" href="#AlternatingProjections.ConstrainedByShape"><code>AlternatingProjections.ConstrainedByShape</code></a> — <span class="docstring-category">Type</span></header><section><div><p>ConstrainedByShape{T,N}</p><p>Set of abstract arryas with elemet typ <code>T</code> and dimensions <code>N defined by the shape constraint</code>|x| = s amp<code>for some</code>s`.  Field n contains the sum of square of all elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/olejorik/AlternatingProjections.jl/blob/1bb4f87c979af6c2afc8a0508a9c358c857bb313/src/ShapeConstraint.jl#L4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AlternatingProjections.ConstrainedByShape-Union{Tuple{AbstractArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}" href="#AlternatingProjections.ConstrainedByShape-Union{Tuple{AbstractArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}"><code>AlternatingProjections.ConstrainedByShape</code></a> — <span class="docstring-category">Method</span></header><section><div><p>ConstrainedByShape(a::AbstractArray{T,N})</p><p>Construct set defined by the shape constraint <code>|x| = s a</code> for some scaling <code>s</code>. Type and dimension of the set are inhereited from the array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/olejorik/AlternatingProjections.jl/blob/1bb4f87c979af6c2afc8a0508a9c358c857bb313/src/ShapeConstraint.jl#L15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AlternatingProjections.ConstrainedByShapeMasked" href="#AlternatingProjections.ConstrainedByShapeMasked"><code>AlternatingProjections.ConstrainedByShapeMasked</code></a> — <span class="docstring-category">Type</span></header><section><div><p>ConstrainedByAmplitudeMasked(a, mask::Vector) ConstrainedByAmplitudeMasked(a, AbstractArray{Bool})</p><p>The amplitude constrained set only in the indexes given by mask:  <code>|xᵢ| = aᵢ</code> for <code>i ∈ mask</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/olejorik/AlternatingProjections.jl/blob/1bb4f87c979af6c2afc8a0508a9c358c857bb313/src/ShapeConstraint.jl#L33-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AlternatingProjections.ConstrainedByShapeSaturated" href="#AlternatingProjections.ConstrainedByShapeSaturated"><code>AlternatingProjections.ConstrainedByShapeSaturated</code></a> — <span class="docstring-category">Type</span></header><section><div><p>ConstrainedByShapeSaturated(a, mask::Vector) ConstrainedByShapeSaturated(a, AbstractArray{Bool})</p><p>The amplitude constrained set only in the indexes given by mask:  <code>|xᵢ| = s aᵢ</code> for <code>i ∈ mask</code> for some <code>s</code>. Outside the mask function should be larger than the satruation level <code>|xᵢ| &gt; s</code> for <code>i ∉ mask</code>.</p><p>For this set, the amplitude should be provided in the range from 0 to 1 (1 corresponding to the saturated values).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/olejorik/AlternatingProjections.jl/blob/1bb4f87c979af6c2afc8a0508a9c358c857bb313/src/ShapeConstraint.jl#L53-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AlternatingProjections.ConstrainedBySupport" href="#AlternatingProjections.ConstrainedBySupport"><code>AlternatingProjections.ConstrainedBySupport</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConstrainedBySupport(support)</code></pre><p>Special type of convex set.</p><p>For continuous case: consists of all functions that equals zero outside some fixed area called support: <span>$𝓐_S = \{f : f(x) = 0, x ∉ S \} .$</span></p><p>For discrete case: all arrays that equals zero for indexes outside some index set: <span>$𝓐_S = \{x : x[i] = 0, i ∉ S \} .$</span></p><p>Currently supports only discrete case, with the support defined as a boolean array.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; S =  ConstrainedBySupport([true, false,true])
ConstrainedBySupport(Bool[1, 0, 1])

julia&gt; x = [1, 2, 3]; project(x, S)
3-element Vector{Int64}:
 1
 0
 3

julia&gt; S = ConstrainedBySupport([x^2 + y^2 &lt;=1  for x in -2:.5:2, y in -2:.5:2]);

julia&gt; x = ones(size(S.support));

julia&gt; project(x,S)
9×9 Matrix{Float64}:
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  1.0  1.0  1.0  0.0  0.0  0.0
 0.0  0.0  1.0  1.0  1.0  1.0  1.0  0.0  0.0
 0.0  0.0  0.0  1.0  1.0  1.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/olejorik/AlternatingProjections.jl/blob/1bb4f87c979af6c2afc8a0508a9c358c857bb313/src/SupportConstraint.jl#L7-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AlternatingProjections.ConstrainedBySupportNormed" href="#AlternatingProjections.ConstrainedBySupportNormed"><code>AlternatingProjections.ConstrainedBySupportNormed</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConstrainedBySupportNormed(support, norm)</code></pre><p><code>ConstrainedBySupportNormed(support, norm)</code> is a set represented by intersection of the  <code>ConstrainedBySupport(support)</code> set and a hypersphere of radius <code>norm</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt;  a = rand((1,10),(5,5));

julia&gt; mask = a .&gt; 5;

julia&gt; aset= ConstrainedBySupportNormed(mask, 10);

julia&gt; b = project(Float64.(a), aset);

julia&gt; sum(abs2,b) ≈ 10^2
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/olejorik/AlternatingProjections.jl/blob/1bb4f87c979af6c2afc8a0508a9c358c857bb313/src/SupportConstraint.jl#L66-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AlternatingProjections.ConvexSet" href="#AlternatingProjections.ConvexSet"><code>AlternatingProjections.ConvexSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConvexSet</code></pre><p>General type, no projection method is specified. For a convex set a projection is unique.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/olejorik/AlternatingProjections.jl/blob/1bb4f87c979af6c2afc8a0508a9c358c857bb313/src/AlternatingProjections.jl#L61-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AlternatingProjections.DR" href="#AlternatingProjections.DR"><code>AlternatingProjections.DR</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DR &lt;: ProjectionsMethod</code></pre><p>Douglas-Rachford method</p><p>Reflect with respect one set, than to another and move there halfway: <code>x → (x + R₂R₁x)/2</code>. Stop after fixed number of iterations or if the desired accuracy is achieved</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/olejorik/AlternatingProjections.jl/blob/1bb4f87c979af6c2afc8a0508a9c358c857bb313/src/DR.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AlternatingProjections.DRAP" href="#AlternatingProjections.DRAP"><code>AlternatingProjections.DRAP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DRAP &lt;: ProjectionsMethod</code></pre><p>Douglas-Rachford and Alternating Projection method</p><p>Combination of DR and AP method (see [1]). Stop after fixed number of iterations or if the desired accuracy is achieved</p><p>[1] Nguyen Hieu Thao, Oleg Soloviev, and Michel Verhaegen. Convex combination of alternating     projection and Douglas-Rachford operators for phase retrieval. Adv. Comput. Math.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/olejorik/AlternatingProjections.jl/blob/1bb4f87c979af6c2afc8a0508a9c358c857bb313/src/DRAP.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AlternatingProjections.FeasibilityProblem" href="#AlternatingProjections.FeasibilityProblem"><code>AlternatingProjections.FeasibilityProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Big class of feasibility problems./</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/olejorik/AlternatingProjections.jl/blob/1bb4f87c979af6c2afc8a0508a9c358c857bb313/src/AlternatingProjections.jl#L43-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AlternatingProjections.FeasibleSet" href="#AlternatingProjections.FeasibleSet"><code>AlternatingProjections.FeasibleSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FeasibleSet</code></pre><p>Abstract type representing a set for feasibility problem.      For any set we should be able to take it&#39;s representative element.</p><p>For any concrete subtype, we define a project operator (maybe set-valued).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/olejorik/AlternatingProjections.jl/blob/1bb4f87c979af6c2afc8a0508a9c358c857bb313/src/AlternatingProjections.jl#L30-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AlternatingProjections.LinearTransformedSet" href="#AlternatingProjections.LinearTransformedSet"><code>AlternatingProjections.LinearTransformedSet</code></a> — <span class="docstring-category">Type</span></header><section><div><p>LinearTransformedSet</p><p>Subtype of TransformedSet where <code>forward</code> and <code>backward</code> transformations are given by multiplication  by forward and backward &quot;plans&quot; (i.e. – precomputed matrices). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/olejorik/AlternatingProjections.jl/blob/1bb4f87c979af6c2afc8a0508a9c358c857bb313/src/TransformedSet.jl#L35-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AlternatingProjections.Opiterator1" href="#AlternatingProjections.Opiterator1"><code>AlternatingProjections.Opiterator1</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Opiterator1(x⁰, f)</code></pre><p>Create a simple iteration with operator <code>f</code> and inital value <code>x⁰</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ttt = Opiterator([3], x -&gt; x .+ 2)
AlternatingProjections.Opiterator1{Vector{Int64}}([3], var&quot;#11#12&quot;())

julia&gt; for state in Base.Iterators.take(ttt,5)
       println(state.xᵏ[1])
       end
5
7
9
11
13

julia&gt; ttt20 = Iterators.take(ttt,20);

julia&gt; for state in ttt20
       print(state.xᵏ[1])
       end
5791113151719212325272931333537394143</code></pre><p><strong>Example with Images.jl</strong></p><pre><code class="nohighlight hljs">julia&gt; using Images

julia&gt; img = Gray.(rand(Float64, (256,256)))

julia&gt; blurop = Opiterator(img, x -&gt; imfilter(x, Kernel.gaussian(2)));

julia&gt; blurop20 = Iterators.take(blurop, 20);

julia&gt; mosaic([copy(b.xᵏ⁻¹) for b in blurop20]; nrow=4, rowmajor = true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/olejorik/AlternatingProjections.jl/blob/1bb4f87c979af6c2afc8a0508a9c358c857bb313/src/iterators.jl#L41-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AlternatingProjections.ProjectionsMethod" href="#AlternatingProjections.ProjectionsMethod"><code>AlternatingProjections.ProjectionsMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><p>ProjectionsMethod is class of iterative algorithms for solving feasibility problems based on projections on the feasible sets.     Examples are Alternating Projections (AP), also known in the literature as Projections on the Convex Sets (POCS),     Douglas-Rachford algorithm (DR), their combination DRAP and many others.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/olejorik/AlternatingProjections.jl/blob/1bb4f87c979af6c2afc8a0508a9c358c857bb313/src/AlternatingProjections.jl#L116-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AlternatingProjections.TransformedSet" href="#AlternatingProjections.TransformedSet"><code>AlternatingProjections.TransformedSet</code></a> — <span class="docstring-category">Type</span></header><section><div><p>TransformedSet</p><p>Set obtained by some transformation from a feasible set (<code>generatingset</code>). Should support <code>forward!</code> and <code>backward!</code> methods. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/olejorik/AlternatingProjections.jl/blob/1bb4f87c979af6c2afc8a0508a9c358c857bb313/src/TransformedSet.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AlternatingProjections.TwoSetsFP" href="#AlternatingProjections.TwoSetsFP"><code>AlternatingProjections.TwoSetsFP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TwoSetsFP(A,B)</code></pre><p>Two sets feasibility problem: for given sets A and B find x∈A∩B, if A∩B≠∅, or x∈A closest to B in some sense.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/olejorik/AlternatingProjections.jl/blob/1bb4f87c979af6c2afc8a0508a9c358c857bb313/src/AlternatingProjections.jl#L48-L53">source</a></section></article><h2 id="AbstractProblems"><a class="docs-heading-anchor" href="#AbstractProblems">AbstractProblems</a><a id="AbstractProblems-1"></a><a class="docs-heading-anchor-permalink" href="#AbstractProblems" title="Permalink"></a></h2><p>The types defined here are absract and not related exclusevely to the alternating projections methos.</p><article class="docstring"><header><a class="docstring-binding" id="AlternatingProjections.AbstractProblems" href="#AlternatingProjections.AbstractProblems"><code>AlternatingProjections.AbstractProblems</code></a> — <span class="docstring-category">Module</span></header><section><div><p>A collection of abstract types representing problems and methods for their solution</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/olejorik/AlternatingProjections.jl/blob/1bb4f87c979af6c2afc8a0508a9c358c857bb313/src/AbstractProblems.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AlternatingProjections.AbstractProblems.initial-Tuple{IterativeAlgorithm}" href="#AlternatingProjections.AbstractProblems.initial-Tuple{IterativeAlgorithm}"><code>AlternatingProjections.AbstractProblems.initial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial(alg::IterativeAlgorithm)</code></pre><p>Get the inital value of  iterative algorithm <code>alg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/olejorik/AlternatingProjections.jl/blob/1bb4f87c979af6c2afc8a0508a9c358c857bb313/src/AbstractProblems.jl#L33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AlternatingProjections.AbstractProblems.keephistory-Tuple{IterativeAlgorithm}" href="#AlternatingProjections.AbstractProblems.keephistory-Tuple{IterativeAlgorithm}"><code>AlternatingProjections.AbstractProblems.keephistory</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">keephistory(alg::IterativeAlgorithm)::Bool</code></pre><p>If set, iterative algorithm <code>alg</code> will keep the history of the error values (distances between subsequent states).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/olejorik/AlternatingProjections.jl/blob/1bb4f87c979af6c2afc8a0508a9c358c857bb313/src/AbstractProblems.jl#L54-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AlternatingProjections.AbstractProblems.maxit-Tuple{IterativeAlgorithm}" href="#AlternatingProjections.AbstractProblems.maxit-Tuple{IterativeAlgorithm}"><code>AlternatingProjections.AbstractProblems.maxit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">maxit(alg::IterativeAlgorithm)::Int</code></pre><p>Get the maximum number of iterations used as stopping criterium of iterative algorithm <code>alg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/olejorik/AlternatingProjections.jl/blob/1bb4f87c979af6c2afc8a0508a9c358c857bb313/src/AbstractProblems.jl#L47-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AlternatingProjections.AbstractProblems.snapshots-Tuple{IterativeAlgorithm}" href="#AlternatingProjections.AbstractProblems.snapshots-Tuple{IterativeAlgorithm}"><code>AlternatingProjections.AbstractProblems.snapshots</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">snapshots(alg::IterativeAlgorithm)::Array{Int64}</code></pre><p>Get the list of the iteration numbers, for which iterative algorithm <code>alg</code> will keep the state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/olejorik/AlternatingProjections.jl/blob/1bb4f87c979af6c2afc8a0508a9c358c857bb313/src/AbstractProblems.jl#L61-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AlternatingProjections.AbstractProblems.solve-Tuple{Problem, Algorithm}" href="#AlternatingProjections.AbstractProblems.solve-Tuple{Problem, Algorithm}"><code>AlternatingProjections.AbstractProblems.solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve(p::Problem,x⁰,alg::Algorithm)

solve(p::Problem,alg::IterativeAlgorithm; x⁰, ϵ, maxit, keephistory, snapshshots)

solve(p::Problem,(alg1, alg2,...); x⁰, ϵ, maxit, keephistory, snapshshots)</code></pre><p>Solve problem <code>p</code>, using method <code>alg</code>. For iterative algorithms the arguments may be specified separately. Optionally keep the error history and the iteration snapshots.</p><p>If sequence of the iterative algorithms is given, they are run subsequently, using the last state of the previous algorith as the inital value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/olejorik/AlternatingProjections.jl/blob/1bb4f87c979af6c2afc8a0508a9c358c857bb313/src/AbstractProblems.jl#L69-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AlternatingProjections.AbstractProblems.tolerance-Tuple{IterativeAlgorithm}" href="#AlternatingProjections.AbstractProblems.tolerance-Tuple{IterativeAlgorithm}"><code>AlternatingProjections.AbstractProblems.tolerance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tolerance(alg::IterativeAlgorithm)::Float64</code></pre><p>Get the tolerance value used as stopping criterium of iterative algorithm <code>alg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/olejorik/AlternatingProjections.jl/blob/1bb4f87c979af6c2afc8a0508a9c358c857bb313/src/AbstractProblems.jl#L40-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AlternatingProjections.AbstractProblems.Algorithm" href="#AlternatingProjections.AbstractProblems.Algorithm"><code>AlternatingProjections.AbstractProblems.Algorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type containing any algorithm</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/olejorik/AlternatingProjections.jl/blob/1bb4f87c979af6c2afc8a0508a9c358c857bb313/src/AbstractProblems.jl#L13-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AlternatingProjections.AbstractProblems.IterativeAlgorithm" href="#AlternatingProjections.AbstractProblems.IterativeAlgorithm"><code>AlternatingProjections.AbstractProblems.IterativeAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Iterative methods form an important class of algorithms with iteratively adjust solution.</p><p>Concrete types of the <code>IterativeAlgorithm</code> should contain the initial value, tolerance and maximum number of iterations and  are used more for convenience. These can be obtained by fucntions <code>initial</code>, <code>tolerance</code>, <code>maxit</code> fuctions. If applied the abstract types, these fucntions return <code>missing</code> and can trigger using of the default values.</p><p>In addition, the concrete types contain instructions on whether or not to keeep the history of the convergence and  some snapshots of the inner state of an iterator. These values are given by functions <code>keephistory</code> and <code>snapshots</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/olejorik/AlternatingProjections.jl/blob/1bb4f87c979af6c2afc8a0508a9c358c857bb313/src/AbstractProblems.jl#L20-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AlternatingProjections.AbstractProblems.Problem" href="#AlternatingProjections.AbstractProblems.Problem"><code>AlternatingProjections.AbstractProblems.Problem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type representing a problem to solve</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/olejorik/AlternatingProjections.jl/blob/1bb4f87c979af6c2afc8a0508a9c358c857bb313/src/AbstractProblems.jl#L8-L10">source</a></section></article><h1 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h1><ul><li><a href="#AlternatingProjections"><code>AlternatingProjections</code></a></li><li><a href="#AlternatingProjections.AbstractProblems"><code>AlternatingProjections.AbstractProblems</code></a></li><li><a href="#AlternatingProjections.ACset"><code>AlternatingProjections.ACset</code></a></li><li><a href="#AlternatingProjections.AP"><code>AlternatingProjections.AP</code></a></li><li><a href="#AlternatingProjections.AbstractProblems.Algorithm"><code>AlternatingProjections.AbstractProblems.Algorithm</code></a></li><li><a href="#AlternatingProjections.AbstractProblems.IterativeAlgorithm"><code>AlternatingProjections.AbstractProblems.IterativeAlgorithm</code></a></li><li><a href="#AlternatingProjections.AbstractProblems.Problem"><code>AlternatingProjections.AbstractProblems.Problem</code></a></li><li><a href="#AlternatingProjections.AmplitudeConstrainedSet"><code>AlternatingProjections.AmplitudeConstrainedSet</code></a></li><li><a href="#AlternatingProjections.ConstrainedByAmplitude-Union{Tuple{AbstractArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}"><code>AlternatingProjections.ConstrainedByAmplitude</code></a></li><li><a href="#AlternatingProjections.ConstrainedByAmplitude"><code>AlternatingProjections.ConstrainedByAmplitude</code></a></li><li><a href="#AlternatingProjections.ConstrainedByAmplitudeMasked"><code>AlternatingProjections.ConstrainedByAmplitudeMasked</code></a></li><li><a href="#AlternatingProjections.ConstrainedByShape"><code>AlternatingProjections.ConstrainedByShape</code></a></li><li><a href="#AlternatingProjections.ConstrainedByShape-Union{Tuple{AbstractArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}"><code>AlternatingProjections.ConstrainedByShape</code></a></li><li><a href="#AlternatingProjections.ConstrainedByShapeMasked"><code>AlternatingProjections.ConstrainedByShapeMasked</code></a></li><li><a href="#AlternatingProjections.ConstrainedByShapeSaturated"><code>AlternatingProjections.ConstrainedByShapeSaturated</code></a></li><li><a href="#AlternatingProjections.ConstrainedBySupport"><code>AlternatingProjections.ConstrainedBySupport</code></a></li><li><a href="#AlternatingProjections.ConstrainedBySupportNormed"><code>AlternatingProjections.ConstrainedBySupportNormed</code></a></li><li><a href="#AlternatingProjections.ConvexSet"><code>AlternatingProjections.ConvexSet</code></a></li><li><a href="#AlternatingProjections.DR"><code>AlternatingProjections.DR</code></a></li><li><a href="#AlternatingProjections.DRAP"><code>AlternatingProjections.DRAP</code></a></li><li><a href="#AlternatingProjections.FeasibilityProblem"><code>AlternatingProjections.FeasibilityProblem</code></a></li><li><a href="#AlternatingProjections.FeasibleSet"><code>AlternatingProjections.FeasibleSet</code></a></li><li><a href="#AlternatingProjections.LinearTransformedSet"><code>AlternatingProjections.LinearTransformedSet</code></a></li><li><a href="#AlternatingProjections.Opiterator1"><code>AlternatingProjections.Opiterator1</code></a></li><li><a href="#AlternatingProjections.ProjectionsMethod"><code>AlternatingProjections.ProjectionsMethod</code></a></li><li><a href="#AlternatingProjections.TransformedSet"><code>AlternatingProjections.TransformedSet</code></a></li><li><a href="#AlternatingProjections.TwoSetsFP"><code>AlternatingProjections.TwoSetsFP</code></a></li><li><a href="#AlternatingProjections.AbstractProblems.initial-Tuple{IterativeAlgorithm}"><code>AlternatingProjections.AbstractProblems.initial</code></a></li><li><a href="#AlternatingProjections.AbstractProblems.keephistory-Tuple{IterativeAlgorithm}"><code>AlternatingProjections.AbstractProblems.keephistory</code></a></li><li><a href="#AlternatingProjections.AbstractProblems.maxit-Tuple{IterativeAlgorithm}"><code>AlternatingProjections.AbstractProblems.maxit</code></a></li><li><a href="#AlternatingProjections.AbstractProblems.snapshots-Tuple{IterativeAlgorithm}"><code>AlternatingProjections.AbstractProblems.snapshots</code></a></li><li><a href="#AlternatingProjections.AbstractProblems.solve-Tuple{Problem, Algorithm}"><code>AlternatingProjections.AbstractProblems.solve</code></a></li><li><a href="#AlternatingProjections.AbstractProblems.tolerance-Tuple{IterativeAlgorithm}"><code>AlternatingProjections.AbstractProblems.tolerance</code></a></li><li><a href="#AlternatingProjections.forward!-Tuple{TransformedSet}"><code>AlternatingProjections.forward!</code></a></li><li><a href="#AlternatingProjections.project-Tuple{Any, FeasibleSet}"><code>AlternatingProjections.project</code></a></li><li><a href="#AlternatingProjections.project!-Tuple{Any, Any, FeasibleSet}"><code>AlternatingProjections.project!</code></a></li><li><a href="#AlternatingProjections.project!-Tuple{Any, FeasibleSet}"><code>AlternatingProjections.project!</code></a></li><li><a href="#AlternatingProjections.reflect!-Tuple{Any, Any, FeasibleSet}"><code>AlternatingProjections.reflect!</code></a></li></ul><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>not implemented features are shown with italics</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="methodology/">Second purpose of this package »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.18 on <span class="colophon-date" title="Friday 3 June 2022 18:32">Friday 3 June 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
